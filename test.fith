\ test.fith start

fib(n){
    n 2 <{
        n return
    }{
        n 1 - fib n 2 - fib + return
    }
}

fib2{
    dup 2 >={
        dup 1 - fib2 swap 2 - fib2 +
    }
}

fib3(x){
    0 n0;
    1 n1;
    0 n2;
    while x 0 >{
        n0 n1 + n2=
        n1 n0=
        n2 n1=
        x 1 - x=
    }
    n2
}

"Going to print some characters to stress armFith" psn 60 60 +
55 55 + 100 *
"Next line" psn dup p

div?( dividend divisor ){ dividend divisor % 0 ={ 1 }else{ 0 } }
div3( dividend ){ dividend 3 div? }
div5( dividend ){ dividend 5 div? }
0 sum;
pe1( limit ){ 
    do{
        limit div3  
        dup 0 ={
            limit div5 + 
        }
        limit * 
        sum + sum= 
        1 limit-= 
    limit 0 !}
    sum
}

pe2( limit ){ 
    do{
        limit div3 limit div5 or p "line 2" psn
        limit * p "line 3" psn
        sum p + sum= "line 4" psn
        limit 1 - limit= p "line 5" psn
    limit 0 !}
    sum
}

pe3( limit ){ 
    do{
        limit div3 limit div5 or "line 2" psn
        limit * "line 3" psn
        sum + sum= "line 4" psn
        limit 1 - limit= "line 5" psn
    limit 0 !}
    sum
}

printMe(a b){ ."%a% things chased me down h%b% stairs." }

coTestFunc(input){
    ."%input% coconuts"
    input 10 * co-return input=
    ."%input% doggies"
    input 10 * co-return input=
    ."%input% cats"
    input 10 * co-return input=
    ."%input% zebras"
    input 10 *
}

keyCmp( key1 key2 key1Len key2Len ){

	0 i;
	repeat{
		key1 i + $ c1;
		key2 i + $ c2; i 4 + i=
		c1 c2 - c1=
		c1 0 !{ c1 return }
		i key1Len >={ key1Len key2Len - return }
	}
}

keyCmp2( key1 key2 key1Len key2Len ){

	0
	repeat{
		dup dup key1 + $ \ c1;
		swap key2 + $ \ c2; \ i 4 + i=
		\ c1 c2 - c1=
		- dup 0 !{ return } drop
		dup key1Len >={ key1Len key2Len - return } 4 +
	}
}

keyCmp(u8 *key1, u8 *key2, s32 key1Len, s32 key2Len)
{
	s32 c1, c2, i = 0;
	
	while(1){
		c1=key1[i];
		c2=key2[i++];
		c1-=c2;
		if (c1 != 0) { return c1; }
		if (i >= key1Len) { return key1Len - key2Len; }
	}
}


\ test.fith end
